/**
 * generateSnippets.js
 *
 * One-time script that uses the Gemini API to generate a large bank of
 * typing-test snippets and writes them to:
 *   frontend/src/data/snippets.js
 *
 * Usage:
 *   GEMINI_API_KEY=<key> node scripts/generateSnippets.js
 *   (or add GEMINI_API_KEY to backend/.env and just run: node scripts/generateSnippets.js)
 *
 * Options (env vars):
 *   SNIPPETS_PER_COMBO=3   how many snippets per language+difficulty combo (default 3)
 *   DRY_RUN=true           print to stdout instead of writing the file
 */

import 'dotenv/config'
import { GoogleGenerativeAI } from '@google/generative-ai'
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const OUT_FILE = path.resolve(__dirname, '../../frontend/src/data/snippets.js')

const LANGUAGES = ['JavaScript', 'TypeScript', 'Python', 'Java', 'C++', 'Go', 'Rust']
const DIFFICULTIES = ['easy', 'medium', 'hard']
const PER_COMBO = parseInt(process.env.SNIPPETS_PER_COMBO ?? '3', 10)
const DRY_RUN = process.env.DRY_RUN === 'true'

const API_KEY = process.env.GEMINI_API_KEY
if (!API_KEY) {
  console.error('âŒ  GEMINI_API_KEY is not set. Add it to backend/.env or pass it as an env var.')
  process.exit(1)
}

const genAI = new GoogleGenerativeAI(API_KEY)
const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })

// â”€â”€ Prompt builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildPrompt(language, difficulty, count) {
  const diffDesc = {
    easy:   'simple constructs â€” variables, loops, basic functions, ~5-10 lines',
    medium: 'algorithms, data structures, OOP or functional patterns, ~10-20 lines',
    hard:   'advanced patterns â€” generics, concurrency, complex algorithms, ~15-25 lines',
  }[difficulty]

  return `Generate exactly ${count} unique ${language} code snippets for a typing test.

Rules:
- Difficulty: ${difficulty} (${diffDesc})
- Each snippet must be realistic, idiomatic ${language}
- No markdown fences, no explanations â€” pure code only
- Separate each snippet with exactly this delimiter on its own line: ---SNIPPET---
- Do NOT number the snippets
- Avoid snippets that are just hello-world copies; vary the topics (sorting, trees, HTTP, math, IO, etc.)

Return ONLY the ${count} snippets separated by ---SNIPPET---`
}

// â”€â”€ Rate-limit helper (simple sequential with delay) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))

// â”€â”€ Main generation loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function generate() {
  const snippets = []
  let globalIndex = 1

  for (const language of LANGUAGES) {
    for (const difficulty of DIFFICULTIES) {
      const langSlug = language.toLowerCase().replace(/[^a-z0-9]/g, '')
      console.log(`â³  Generating ${PER_COMBO}x ${language} / ${difficulty} â€¦`)

      try {
        const prompt = buildPrompt(language, difficulty, PER_COMBO)
        const result = await model.generateContent(prompt)
        const text = result.response.text().trim()

        const parts = text.split('---SNIPPET---').map((s) => s.trim()).filter(Boolean)

        if (parts.length === 0) {
          console.warn(`   âš ï¸  No snippets parsed for ${language}/${difficulty}`)
          continue
        }

        for (const content of parts.slice(0, PER_COMBO)) {
          snippets.push({
            id: `${langSlug}-gen-${globalIndex++}`,
            language,
            difficulty,
            content,
          })
        }

        console.log(`   âœ…  Got ${Math.min(parts.length, PER_COMBO)} snippets`)
      } catch (err) {
        console.error(`   âŒ  Error for ${language}/${difficulty}:`, err.message)
      }

      // Be polite to the API â€” 500 ms between calls
      await sleep(500)
    }
  }

  return snippets
}

// â”€â”€ Serialise to JS module â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function serialise(snippets) {
  const entries = snippets
    .map(({ id, language, difficulty, content }) => {
      // Escape backticks inside the content so the template literal stays valid
      const escaped = content.replace(/`/g, '\\`').replace(/\$\{/g, '\\${')
      return `  {
    id: ${JSON.stringify(id)},
    language: ${JSON.stringify(language)},
    difficulty: ${JSON.stringify(difficulty)},
    content: \`${escaped}\`,
  }`
    })
    .join(',\n')

  return `// AUTO-GENERATED by scripts/generateSnippets.js â€” do not edit by hand\nexport const snippets = [\n${entries}\n]\n`
}

// â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
;(async () => {
  console.log(`\nðŸš€  Starting snippet generation`)
  console.log(`   Languages : ${LANGUAGES.join(', ')}`)
  console.log(`   Difficulty: ${DIFFICULTIES.join(', ')}`)
  console.log(`   Per combo : ${PER_COMBO}`)
  console.log(`   Total est : ${LANGUAGES.length * DIFFICULTIES.length * PER_COMBO}\n`)

  const snippets = await generate()
  console.log(`\nðŸ“¦  Total snippets generated: ${snippets.length}`)

  const output = serialise(snippets)

  if (DRY_RUN) {
    console.log('\n--- DRY RUN OUTPUT ---\n')
    console.log(output)
  } else {
    fs.writeFileSync(OUT_FILE, output, 'utf8')
    console.log(`\nâœ…  Written to ${OUT_FILE}`)
  }
})()
